// Copyright 2007 Xito.org
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package org.xito.blx;

import java.net.*;
import java.util.*;
import java.util.logging.*;
import org.w3c.dom.*;

import org.xito.boot.*;

/**
 * A BLX Extension is used to encapsulate information about a BLX based Extension package.
 * A BLX Extension is one or more jar files containing BLX objects that is represented by a BXE
 * (BLX Extension File).
 * A BXE file describes the details of a BLX Extension
 *
 * @author drichan
 * @version $Revision: 1.4 $
 * @since $Date: 2007/09/02 00:42:59 $
 */
public class BLXExtension extends ExecutableDesc {
   
   public static final String FILE_EXT = ".blxe";
   public static final String BLX_NS = "blx";
   public static final String BLX_SRV_ELEMENT = "service"; 
   public static final String BLX_EXT_ELEMENT = "extension";
   public static final String BLX_EXT_NAME_ELEMENT = "name";
   public static final String BLX_EXT_DESC_ELEMENT = "description";
   public static final String BLX_EXT_VERSION_ELEMENT = "version";
   public static final String BLX_EXT_CLASSPATH_ELEMENT = "classpath"; 
   
   private static Logger logger = Logger.getLogger(BLXExtension.class.getName());
   
   /** Distinct name provided by a naming service to name this BLX Extension */
   private String extName;
   
   /** Descriptive Title of a BLX Extension */
   private String extDesc;
   
   /** Version of the BLX Extention using format 1.1.1.1 etc. */
   private String extVersion;
   
   /** The URI to the defined Extension. Used when the Extension cannot be found in a naming service */
   private String extHREF;
   
   /** Unique ID generated by blxgen application for this BLX Extension */
   private String extUUID;
   
   /** Extension references */
   private ArrayList extensionRefs;
   
   /** ClassLoader for this extension */
   private BLXExtClassLoader extClassLoader;
   
   private URL contextURL;
   
   /** flag to determine if this extension is loaded from a service */
   private boolean serviceExt_flag = false;
   
   /** ServiceName if this extension is a service or null otherwise */
   private String serviceName;

   
   /**
    * Creates a BLXExtension object from a DOM Element that represents a BLX Extension
    * @doc element to parse
    * @contextURL url used to resolve relative associations of this extension
    * @throws InvalidBLXXMLException if the element does not represent a BLX Extension
    * @throws ServiceNotFoundException if a service required by this Extension is not found
    * @throws ExtensionLoadException if this Extension could not be loaded
    */
   protected BLXExtension(org.w3c.dom.Document doc, URL contextURL) throws InvalidBLXXMLException, ServiceNotFoundException, ExtensionLoadException {
      extHREF = contextURL.toString();
      this.contextURL = contextURL;
      
      processNode(doc.getDocumentElement());
   }
   
   /**
    * Creates a BLXExtension object from a service name
    * @serviceName name of service
    * @throws ServiceNotFoundException if a service required by this Extension is not found
    * @throws ExtensionLoadException if this Extension could not be loaded
    */
   protected BLXExtension(String serviceName) throws ServiceNotFoundException, ExtensionLoadException {
      serviceExt_flag = true;
      this.serviceName = serviceName;
      ServiceClassLoader srvLoader = ServiceClassLoader.getServiceLoader(new ServiceDescStub(serviceName, null, null));
      extClassLoader = new BLXExtClassLoader(this, srvLoader);
   }
   
   
   
   /**
    * Create a BLXExtension Descriptor. Only the href can be null
    */
   protected BLXExtension(String name, String desc, String version, String href, String id) {
      extName = name;
      extDesc = desc;
      extHREF = href;
      extUUID = id;
   }

   @Override
   public String getDisplayExecutableType() {
      return "Extension";
   }

   /**
    * Get the Context URL of this Extension
    */
   public URL getContextURL() {
      return contextURL;
   }
   
   /**
    * Get the Extension Name
    */
   public String getName() {
      return extName;
   }
   
   /**
    * Get the Extension Version
    */
   public String getVersion() {
      return extVersion;
   }
   
   /**
    * Get the Extension Title
    */
   public String getDesc() {
      return extDesc;
   }
   
   /**
    * Get the Extension HREF
    */
   public String getHREF() {
      return extHREF;
   }
    
   /**
    * Get array or extension hrefs this extension should reference
    */
   public String[] getExtensionRefs() {
      if(extensionRefs == null) return new String[0];
      
      String[] refs = new String[extensionRefs.size()];
      return (String[])extensionRefs.toArray(refs);
   }
   
   public boolean isService() {
      return serviceExt_flag;
   }
   
   /**
    * Return the ServiceInfo object for this extension if this extension is actually a service
    */
   public String getServiceName() {
      return serviceName;
   }
   
   /**
    * Process a BLXExtension XML Element
    */
   private void processNode(Element e) throws InvalidBLXXMLException, ServiceNotFoundException, ExtensionLoadException {
      
      String nodeName = BLXUtility.getLocalNodeName(e);
      if(nodeName.equals(BLX_EXT_ELEMENT)==false) {
         throw new InvalidBLXXMLException("Invalid is not a BLX Extension Element name:"+nodeName);
      }
      processExtNode(e);
            
      //Setup ClassLoader
      if((classpath != null && !classpath.isEmpty()) || isService()) {
         extClassLoader = new BLXExtClassLoader(this);
      }
   }
   
   /**
    * Process an EXT DOM Element
    */
   private void processExtNode(Element e)  throws InvalidBLXXMLException, ServiceNotFoundException, ExtensionLoadException {
            
      try {
         NodeList nodes = e.getChildNodes();
         for(int i=0;i<nodes.getLength();i++) {
            Node node = nodes.item(i);
            if(node.getNodeType() != Node.ELEMENT_NODE) continue;
            
            String nodeName = BLXUtility.getLocalNodeName(node);
            //Ext Name
            if(nodeName.equals(BLX_EXT_NAME_ELEMENT)) {
               extName = node.getFirstChild().getNodeValue();
            }
            //Ext Description
            else if(nodeName.equals(BLX_EXT_DESC_ELEMENT)) {
               extDesc = node.getFirstChild().getNodeValue();
            }
            //Ext Version
            else if(nodeName.equals(BLX_EXT_VERSION_ELEMENT)) {
               extVersion = node.getFirstChild().getNodeValue();
            }
            //ClassPath
            else if(nodeName.equals(BLX_EXT_CLASSPATH_ELEMENT)) {
               processClassPathNode((Element)node);
            }
         }
      }
      catch(DOMException exp) {
         throw new InvalidBLXXMLException(exp.getMessage(), exp);
      }
   }
      
      
   /**
    * Process a classpath Node
    */
   private void processClassPathNode(Element node) throws DOMException {
      
      serviceRefs = new ArrayList();
      extensionRefs = new ArrayList();
      NodeList nodes = node.getChildNodes();
      for(int i=0;i<nodes.getLength();i++) {
         Node cNode = nodes.item(i);
         
         //Service Reference
         if(cNode.getNodeName().equals("service-ref")) {
            if(cNode.getNodeType() == Node.ELEMENT_NODE) {
               String srvName = ((Element)cNode).getAttribute("name");
               serviceRefs.add(srvName);
            }
         }
         
         //Extension Reference
         if(cNode.getNodeName().equals("extension-ref")) {
            if(cNode.getNodeType() == Node.ELEMENT_NODE) {
               String extRefHREF = ((Element)cNode).getAttribute("href");
               extensionRefs.add(extRefHREF);
            }
         }
         
         //Lib Node
         if(cNode.getNodeName().equals("lib")) {
            if(cNode.getNodeType() == Node.ELEMENT_NODE) {
               String libPath = ((Element)cNode).getAttribute("path");
               try {
                  URL libURL = new URL(new URL(extHREF), libPath);
                  addLibToClassPath(libURL);
               }
               catch(MalformedURLException urlExp) {
                  logger.log(Level.WARNING, "Extension: " + extName + " lib path:"+libPath+" is invalid", urlExp);
               }
            }
         }
      }
   }
   
   /**
    * Add a library url to the classpath for this service
    */
   private void addLibToClassPath(URL lib) {
      classpath.add(new ClassPathEntry(lib));
   }
   
   /**
    * Get this Extensions Class Loader
    */
   protected synchronized BLXExtClassLoader getExtClassLoader() {
      
      return extClassLoader;
   }
   
}